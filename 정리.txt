1. 메모리 제한이 512MB일 때 int 변수를 대략 1.2억개 정도 선언할 수 있다.
                 2^7MB개
** 따라서 만약 떠올린 풀이가 int 자료 5억개 배열을 필요로 한다면 해당 풀이는 틀린 풀이 임을 빠르게 check...


2. 배열의 성질
* O(1)에 k번째 원소를 확인/변경 가능
* 추가적으로 소모되는 메모리의 양(overhead)이 거의 없음
* Cache hit rate가 높음
* 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 존재

2-1. 배열 원소 삭제/추가는 시간복잡도가 O(N)이다. (배열 연속성 조건)
2-2. 배열은 데이터를 자주 수정하지 않고, 그냥 쌓아두고 싶을 때 활용된다. 혹은 단순(빠른) 인덱싱이 필요할 때.

3. 그래프의 인접 리스트라는 것을 저장할 때에는 vector를 쓰는게 많이 편해서 vector가 필요하게 되지만 그 전까지는 사실 굳이 배열 대신 vector를 써야하는 상황이 딱히 없다.
3-1. vector끼리 =으로 할당하면 deep copy됨.
3-2. vector.size는 return type이 unsigned int다. overflow 발생하지 않게 주의

4. 연결리스트
4-1. k번째 원소 확인/변경시 O(k)
4-2. 임의의 위치 원소 추가/제거시 O(1)
4-3. Cache hit rate 낮음(원소들이 연속된 메모리에 존재하지 않음), 그러나 할당이 다소 쉬움
4-4. STL에 list로 연결리스트가 존재하는데 DLL임
4-5. LL의 overhead는 O(N)이다.
(* 배열과 연결리스트 모두 선형 자료구조다.)
4-6. STL의 list는 제일 뒤에 있는 원소가 더미 노드라서, list.end()는 더미 노드를 가리킴

5. 스택
5-1. STL stack의 멤버함수는 empty, top, pop, push, size
5-2. STL stack은 스택이 비어있을 때 top, pop함수 호출시 runtime error 발생
5-3. 제일 상단 말고 확인/변경이 원칙적으로 불가

6. 큐
6-1. 제일 앞/뒤가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가
6-2. STL에서 head와 tail 쓰기 전에 비어있는지 무조건 확인하고 해야 함!! 비어있는데 참조나 pop하려하면 runtime error 발생

7. 덱 - Double Ended Queue,  (**Deck과는 다른 단어)
7-1. Restricted Structure의 끝판왕, 양쪽 끝에서 삽입과 삭제가 전부 가능
7-2. Stack과 Queue를 덱의 특수한 예시라고 생각해도 괜찮다.
7-3. 원소 삽입, 제거, 제일 앞 뒤 원소 확인 O(1)
7-4. 제일 앞/뒤가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가하나, STL deque에선 인덱스로 접근 가능
7-5. 덱은 여의봉처럼 앞뒤로 head, tail idx를 증가시키는 자료구조라서 시작 idx가 MX, array size를 2*MX +1 로 지정.
7-6. STL vector와 deque는 상당히 비슷해 보인다. 그러나 vector는 메모리상에 연속되어있고, deque는 모든 원소들이 메모리 상에 연속하게 배치되어 있지 않다.
7-7. 앞쪽에서의 추가/제거가 필요하지 않고 배열과 같은 느낌으로 쓰고싶을 땐 vector를 쓰면 된다.

8. BFS(Breadth First Search) : 너비 우선 탐색
8-1. STL의 utility헤더에 있는 pair가 쓰임.
8-2. BFS는 정석적인 틀이 거의 정해져 있어 걍 코드를 달달 외우는게 낫다.
8-3. 대부분의 BFS코드에선 x가 행, y가 열을 의미한다.

*전역 변수로 잡은 int나 int array는 따로 초기화 안할 시 0으로 채워짐.
*백준 반복문 내부에 주석넣으면 주석넣은대로 메모리 잡아먹음...


